{"id":"shaders.js","dependencies":[{"name":"D:\\Ndev\\stickyimage\\package.json","includedInParent":true,"mtime":1554925944000}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.vertex = exports.fragment = void 0;\nvar fragment = \"\\nuniform vec2 u_resolution;\\n\\nuniform sampler2D u_texture;\\nuniform sampler2D u_texture2;\\nuniform vec2 u_textureFactor;\\nuniform vec2 u_texture2Factor;\\nuniform float u_textureProgress;\\n\\n// RGB\\nuniform vec2 u_rgbPosition;\\nuniform vec2 u_rgbVelocity;\\n\\nvarying vec2 vUv;\\nvec2 centeredAspectRatio(vec2 uvs, vec2 factor){\\n    return uvs * factor - factor /2. + 0.5;\\n}\\nvoid main(){\\n    // On THREE 102 The image is has Y backwards\\n    // vec2 flipedUV = vec2(vUv.x,1.-vUv.y);\\n\\n    vec2 normalizedRgbPos = u_rgbPosition / u_resolution;\\n    normalizedRgbPos.y = 1. - normalizedRgbPos.y; \\n\\n    \\n    vec2 vel = u_rgbVelocity;\\n    float dist = distance(normalizedRgbPos + vel / u_resolution, vUv.xy);\\n\\n    float ratio = clamp(1.0 - dist * 5., 0., 1.);\\n\\n\\n    vec4 tex1 = vec4(1.);\\n    vec4 tex2 = vec4(1.);\\n\\n    vec2 uv = vUv;\\n\\n    uv.x -= sin(uv.y) * ratio / 100. * (vel.x + vel.y) / 7.;\\n    uv.y -= sin(uv.x) * ratio / 100. * (vel.x + vel.y) / 7.;\\n\\n    tex1.r = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).r;\\n    tex2.r = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).r;\\n\\n    \\n    uv.x -= sin(uv.y) * ratio / 150. * (vel.x + vel.y) / 7.;\\n    uv.y -= sin(uv.x) * ratio / 150. * (vel.x + vel.y) / 7.;\\n\\n    tex1.g = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).g;\\n    tex2.g = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).g;\\n    \\n    uv.x -= sin(uv.y) * ratio / 300. * (vel.x + vel.y) / 7.;\\n    uv.y -= sin(uv.x) * ratio / 300. * (vel.x + vel.y) / 7.;\\n\\n    tex1.b = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).b;\\n    tex2.b = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).b;\\n     \\n    \\n\\n\\n    vec4 fulltex1 = texture2D(u_texture, centeredAspectRatio(vUv, u_textureFactor) );\\n    vec4 fulltex2 = texture2D(u_texture2, centeredAspectRatio(vUv, u_texture2Factor));\\n    \\n    vec4 mixedTextures =  mix(tex1,tex2,u_textureProgress);\\n\\n    gl_FragColor = mixedTextures;\\n}\\n\";\nexports.fragment = fragment;\nvar vertex = \"\\n#define PI 3.14159265359\\nuniform float u_offset;\\nuniform float u_progress;\\nuniform float u_direction;\\nuniform float u_time;\\nuniform float u_waveIntensity;\\nvarying vec2 vUv;\\nvoid main(){\\n    vec3 pos = position.xyz;\\n\\n    float distance = length(uv.xy - 0.5 );\\n    float sizeDist = length(vec2(0.5,0.5));\\n    float normalizedDistance = distance/sizeDist ;\\n\\n    float stickOutEffect = normalizedDistance ;\\n    float stickInEffect = -normalizedDistance ;\\n\\n    \\n    float stickEffect = mix(stickOutEffect,stickInEffect, u_direction);\\n\\n    // Backwards V wave.\\n    float stick = 0.5;\\n\\n    float waveIn = u_progress*(1. / stick); \\n    float waveOut =  -( u_progress - 1.) * (1./(1.-stick) );\\n    waveOut = pow(smoothstep(0.,1.,waveOut),0.7);\\n\\n    float stickProgress = min(waveIn, waveOut);\\n\\n\\n\\n\\n\\n    // We can re-use stick Influcse because this oen starts at the same position\\n    float offsetInProgress = clamp(waveIn,0.,1.);\\n\\n    // Invert stickout to get the slope moving upwards to the right\\n    // and move it left by 1\\n    float offsetOutProgress = clamp(1.-waveOut,0.,1.);\\n\\n    float offsetProgress = mix(offsetInProgress,offsetOutProgress,u_direction);\\n\\n\\n    float stickOffset = u_offset;\\n    pos.z += stickEffect * stickOffset * stickProgress  - u_offset * offsetProgress;\\n\\n    \\n    pos.z += sin(distance * 8. - u_time * 2. )  * u_waveIntensity;\\n\\n    gl_Position =   \\n        projectionMatrix * \\n        modelViewMatrix * \\n         vec4(pos, 1.0);\\n\\n    vUv = uv;\\n}\\n\";\nexports.vertex = vertex;"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":7,"column":0},"source":"shaders.js","original":{"line":1,"column":0}},{"name":"fragment","generated":{"line":7,"column":4},"source":"shaders.js","original":{"line":1,"column":6}},{"generated":{"line":7,"column":12},"source":"shaders.js","original":{"line":1,"column":14}},{"generated":{"line":7,"column":2046},"source":"shaders.js","original":{"line":1,"column":0}},{"generated":{"line":9,"column":0},"source":"shaders.js","original":{"line":68,"column":0}},{"name":"vertex","generated":{"line":9,"column":4},"source":"shaders.js","original":{"line":68,"column":6}},{"generated":{"line":9,"column":10},"source":"shaders.js","original":{"line":68,"column":12}},{"generated":{"line":9,"column":1540},"source":"shaders.js","original":{"line":68,"column":0}}],"sources":{"shaders.js":"const fragment = `\nuniform vec2 u_resolution;\n\nuniform sampler2D u_texture;\nuniform sampler2D u_texture2;\nuniform vec2 u_textureFactor;\nuniform vec2 u_texture2Factor;\nuniform float u_textureProgress;\n\n// RGB\nuniform vec2 u_rgbPosition;\nuniform vec2 u_rgbVelocity;\n\nvarying vec2 vUv;\nvec2 centeredAspectRatio(vec2 uvs, vec2 factor){\n    return uvs * factor - factor /2. + 0.5;\n}\nvoid main(){\n    // On THREE 102 The image is has Y backwards\n    // vec2 flipedUV = vec2(vUv.x,1.-vUv.y);\n\n    vec2 normalizedRgbPos = u_rgbPosition / u_resolution;\n    normalizedRgbPos.y = 1. - normalizedRgbPos.y; \n\n    \n    vec2 vel = u_rgbVelocity;\n    float dist = distance(normalizedRgbPos + vel / u_resolution, vUv.xy);\n\n    float ratio = clamp(1.0 - dist * 5., 0., 1.);\n\n\n    vec4 tex1 = vec4(1.);\n    vec4 tex2 = vec4(1.);\n\n    vec2 uv = vUv;\n\n    uv.x -= sin(uv.y) * ratio / 100. * (vel.x + vel.y) / 7.;\n    uv.y -= sin(uv.x) * ratio / 100. * (vel.x + vel.y) / 7.;\n\n    tex1.r = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).r;\n    tex2.r = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).r;\n\n    \n    uv.x -= sin(uv.y) * ratio / 150. * (vel.x + vel.y) / 7.;\n    uv.y -= sin(uv.x) * ratio / 150. * (vel.x + vel.y) / 7.;\n\n    tex1.g = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).g;\n    tex2.g = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).g;\n    \n    uv.x -= sin(uv.y) * ratio / 300. * (vel.x + vel.y) / 7.;\n    uv.y -= sin(uv.x) * ratio / 300. * (vel.x + vel.y) / 7.;\n\n    tex1.b = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).b;\n    tex2.b = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).b;\n     \n    \n\n\n    vec4 fulltex1 = texture2D(u_texture, centeredAspectRatio(vUv, u_textureFactor) );\n    vec4 fulltex2 = texture2D(u_texture2, centeredAspectRatio(vUv, u_texture2Factor));\n    \n    vec4 mixedTextures =  mix(tex1,tex2,u_textureProgress);\n\n    gl_FragColor = mixedTextures;\n}\n`;\n\nconst vertex = `\n#define PI 3.14159265359\nuniform float u_offset;\nuniform float u_progress;\nuniform float u_direction;\nuniform float u_time;\nuniform float u_waveIntensity;\nvarying vec2 vUv;\nvoid main(){\n    vec3 pos = position.xyz;\n\n    float distance = length(uv.xy - 0.5 );\n    float sizeDist = length(vec2(0.5,0.5));\n    float normalizedDistance = distance/sizeDist ;\n\n    float stickOutEffect = normalizedDistance ;\n    float stickInEffect = -normalizedDistance ;\n\n    \n    float stickEffect = mix(stickOutEffect,stickInEffect, u_direction);\n\n    // Backwards V wave.\n    float stick = 0.5;\n\n    float waveIn = u_progress*(1. / stick); \n    float waveOut =  -( u_progress - 1.) * (1./(1.-stick) );\n    waveOut = pow(smoothstep(0.,1.,waveOut),0.7);\n\n    float stickProgress = min(waveIn, waveOut);\n\n\n\n\n\n    // We can re-use stick Influcse because this oen starts at the same position\n    float offsetInProgress = clamp(waveIn,0.,1.);\n\n    // Invert stickout to get the slope moving upwards to the right\n    // and move it left by 1\n    float offsetOutProgress = clamp(1.-waveOut,0.,1.);\n\n    float offsetProgress = mix(offsetInProgress,offsetOutProgress,u_direction);\n\n\n    float stickOffset = u_offset;\n    pos.z += stickEffect * stickOffset * stickProgress  - u_offset * offsetProgress;\n\n    \n    pos.z += sin(distance * 8. - u_time * 2. )  * u_waveIntensity;\n\n    gl_Position =   \n        projectionMatrix * \n        modelViewMatrix * \n         vec4(pos, 1.0);\n\n    vUv = uv;\n}\n`;\n\nexport { fragment, vertex };\n"},"lineCount":null}},"error":null,"hash":"c3cad07e0a2b6b3de31f12a22bad8d55","cacheData":{"env":{}}}