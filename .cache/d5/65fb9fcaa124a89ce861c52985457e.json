{"id":"shaders.js","dependencies":[{"name":"D:\\GIT\\sangheet.github.io\\package.json","includedInParent":true,"mtime":1558105279622}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.vertex = exports.fragment = void 0;\nvar fragment = \"\\nuniform vec2 u_resolution;\\n\\nuniform sampler2D u_texture;\\nuniform sampler2D u_texture2;\\nuniform vec2 u_textureFactor;\\nuniform vec2 u_texture2Factor;\\nuniform float u_textureProgress;\\n\\n// RGB\\nuniform vec2 u_rgbPosition;\\nuniform vec2 u_rgbVelocity;\\n\\nvarying vec2 vUv;\\nvec2 centeredAspectRatio(vec2 uvs, vec2 factor){\\n    return uvs * factor - factor /2. + 0.5;\\n}\\nvoid main(){\\n    // On THREE 102 The image is has Y backwards\\n    // vec2 flipedUV = vec2(vUv.x,1.-vUv.y);\\n\\n    vec2 normalizedRgbPos = u_rgbPosition / u_resolution;\\n    normalizedRgbPos.y = 1. - normalizedRgbPos.y; \\n\\n    \\n    vec2 vel = u_rgbVelocity;\\n    float dist = distance(normalizedRgbPos + vel / u_resolution, vUv.xy);\\n\\n    float ratio = clamp(1.0 - dist * 5., 0., 1.);\\n\\n\\n    vec4 tex1 = vec4(1.);\\n    vec4 tex2 = vec4(1.);\\n\\n    vec2 uv = vUv;\\n\\n    uv.x -= sin(uv.y) * ratio / 100. * (vel.x + vel.y) / 7.;\\n    uv.y -= sin(uv.x) * ratio / 100. * (vel.x + vel.y) / 7.;\\n\\n    tex1.r = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).r;\\n    tex2.r = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).r;\\n\\n    \\n    uv.x -= sin(uv.y) * ratio / 150. * (vel.x + vel.y) / 7.;\\n    uv.y -= sin(uv.x) * ratio / 150. * (vel.x + vel.y) / 7.;\\n\\n    tex1.g = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).g;\\n    tex2.g = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).g;\\n    \\n    uv.x -= sin(uv.y) * ratio / 300. * (vel.x + vel.y) / 7.;\\n    uv.y -= sin(uv.x) * ratio / 300. * (vel.x + vel.y) / 7.;\\n\\n    tex1.b = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).b;\\n    tex2.b = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).b;\\n     \\n    \\n\\n\\n    vec4 fulltex1 = texture2D(u_texture, centeredAspectRatio(vUv, u_textureFactor) );\\n    vec4 fulltex2 = texture2D(u_texture2, centeredAspectRatio(vUv, u_texture2Factor));\\n    \\n    vec4 mixedTextures =  mix(tex1,tex2,u_textureProgress);\\n\\n    gl_FragColor = mixedTextures;\\n}\\n\";\nexports.fragment = fragment;\nvar vertex = \"\\n#define PI 3.14159265359\\nuniform float u_offset;\\nuniform float u_progress;\\nuniform float u_direction;\\nuniform float u_time;\\nuniform float u_waveIntensity;\\nvarying vec2 vUv;\\nvoid main(){\\n    vec3 pos = position.xyz;\\n\\n    float distance = length(uv.xy - 0.5 );\\n    float sizeDist = length(vec2(0.5,0.5));\\n    float normalizedDistance = distance/sizeDist ;\\n\\n    float stickOutEffect = normalizedDistance ;\\n    float stickInEffect = -normalizedDistance ;\\n\\n    \\n    float stickEffect = mix(stickOutEffect,stickInEffect, u_direction);\\n\\n    // Backwards V wave.\\n    float stick = 0.5;\\n\\n    float waveIn = u_progress*(1. / stick); \\n    float waveOut =  -( u_progress - 1.) * (1./(1.-stick) );\\n    waveOut = pow(smoothstep(0.,1.,waveOut),0.7);\\n\\n    float stickProgress = min(waveIn, waveOut);\\n\\n\\n\\n\\n\\n    // We can re-use stick Influcse because this oen starts at the same position\\n    float offsetInProgress = clamp(waveIn,0.,1.);\\n\\n    // Invert stickout to get the slope moving upwards to the right\\n    // and move it left by 1\\n    float offsetOutProgress = clamp(1.-waveOut,0.,1.);\\n\\n    float offsetProgress = mix(offsetInProgress,offsetOutProgress,u_direction);\\n\\n\\n    float stickOffset = u_offset;\\n    pos.z += stickEffect * stickOffset * stickProgress  - u_offset * offsetProgress;\\n\\n    \\n    pos.z += sin(distance * 8. - u_time * 2. )  * u_waveIntensity;\\n\\n    gl_Position =   \\n        projectionMatrix * \\n        modelViewMatrix * \\n         vec4(pos, 1.0);\\n\\n    vUv = uv;\\n}\\n\";\nexports.vertex = vertex;"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":7,"column":0},"source":"shaders.js","original":{"line":1,"column":0}},{"name":"fragment","generated":{"line":7,"column":4},"source":"shaders.js","original":{"line":1,"column":6}},{"generated":{"line":7,"column":12},"source":"shaders.js","original":{"line":1,"column":14}},{"generated":{"line":7,"column":2046},"source":"shaders.js","original":{"line":1,"column":0}},{"generated":{"line":9,"column":0},"source":"shaders.js","original":{"line":68,"column":0}},{"name":"vertex","generated":{"line":9,"column":4},"source":"shaders.js","original":{"line":68,"column":6}},{"generated":{"line":9,"column":10},"source":"shaders.js","original":{"line":68,"column":12}},{"generated":{"line":9,"column":1540},"source":"shaders.js","original":{"line":68,"column":0}}],"sources":{"shaders.js":"const fragment = `\r\nuniform vec2 u_resolution;\r\n\r\nuniform sampler2D u_texture;\r\nuniform sampler2D u_texture2;\r\nuniform vec2 u_textureFactor;\r\nuniform vec2 u_texture2Factor;\r\nuniform float u_textureProgress;\r\n\r\n// RGB\r\nuniform vec2 u_rgbPosition;\r\nuniform vec2 u_rgbVelocity;\r\n\r\nvarying vec2 vUv;\r\nvec2 centeredAspectRatio(vec2 uvs, vec2 factor){\r\n    return uvs * factor - factor /2. + 0.5;\r\n}\r\nvoid main(){\r\n    // On THREE 102 The image is has Y backwards\r\n    // vec2 flipedUV = vec2(vUv.x,1.-vUv.y);\r\n\r\n    vec2 normalizedRgbPos = u_rgbPosition / u_resolution;\r\n    normalizedRgbPos.y = 1. - normalizedRgbPos.y; \r\n\r\n    \r\n    vec2 vel = u_rgbVelocity;\r\n    float dist = distance(normalizedRgbPos + vel / u_resolution, vUv.xy);\r\n\r\n    float ratio = clamp(1.0 - dist * 5., 0., 1.);\r\n\r\n\r\n    vec4 tex1 = vec4(1.);\r\n    vec4 tex2 = vec4(1.);\r\n\r\n    vec2 uv = vUv;\r\n\r\n    uv.x -= sin(uv.y) * ratio / 100. * (vel.x + vel.y) / 7.;\r\n    uv.y -= sin(uv.x) * ratio / 100. * (vel.x + vel.y) / 7.;\r\n\r\n    tex1.r = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).r;\r\n    tex2.r = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).r;\r\n\r\n    \r\n    uv.x -= sin(uv.y) * ratio / 150. * (vel.x + vel.y) / 7.;\r\n    uv.y -= sin(uv.x) * ratio / 150. * (vel.x + vel.y) / 7.;\r\n\r\n    tex1.g = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).g;\r\n    tex2.g = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).g;\r\n    \r\n    uv.x -= sin(uv.y) * ratio / 300. * (vel.x + vel.y) / 7.;\r\n    uv.y -= sin(uv.x) * ratio / 300. * (vel.x + vel.y) / 7.;\r\n\r\n    tex1.b = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).b;\r\n    tex2.b = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).b;\r\n     \r\n    \r\n\r\n\r\n    vec4 fulltex1 = texture2D(u_texture, centeredAspectRatio(vUv, u_textureFactor) );\r\n    vec4 fulltex2 = texture2D(u_texture2, centeredAspectRatio(vUv, u_texture2Factor));\r\n    \r\n    vec4 mixedTextures =  mix(tex1,tex2,u_textureProgress);\r\n\r\n    gl_FragColor = mixedTextures;\r\n}\r\n`;\r\n\r\nconst vertex = `\r\n#define PI 3.14159265359\r\nuniform float u_offset;\r\nuniform float u_progress;\r\nuniform float u_direction;\r\nuniform float u_time;\r\nuniform float u_waveIntensity;\r\nvarying vec2 vUv;\r\nvoid main(){\r\n    vec3 pos = position.xyz;\r\n\r\n    float distance = length(uv.xy - 0.5 );\r\n    float sizeDist = length(vec2(0.5,0.5));\r\n    float normalizedDistance = distance/sizeDist ;\r\n\r\n    float stickOutEffect = normalizedDistance ;\r\n    float stickInEffect = -normalizedDistance ;\r\n\r\n    \r\n    float stickEffect = mix(stickOutEffect,stickInEffect, u_direction);\r\n\r\n    // Backwards V wave.\r\n    float stick = 0.5;\r\n\r\n    float waveIn = u_progress*(1. / stick); \r\n    float waveOut =  -( u_progress - 1.) * (1./(1.-stick) );\r\n    waveOut = pow(smoothstep(0.,1.,waveOut),0.7);\r\n\r\n    float stickProgress = min(waveIn, waveOut);\r\n\r\n\r\n\r\n\r\n\r\n    // We can re-use stick Influcse because this oen starts at the same position\r\n    float offsetInProgress = clamp(waveIn,0.,1.);\r\n\r\n    // Invert stickout to get the slope moving upwards to the right\r\n    // and move it left by 1\r\n    float offsetOutProgress = clamp(1.-waveOut,0.,1.);\r\n\r\n    float offsetProgress = mix(offsetInProgress,offsetOutProgress,u_direction);\r\n\r\n\r\n    float stickOffset = u_offset;\r\n    pos.z += stickEffect * stickOffset * stickProgress  - u_offset * offsetProgress;\r\n\r\n    \r\n    pos.z += sin(distance * 8. - u_time * 2. )  * u_waveIntensity;\r\n\r\n    gl_Position =   \r\n        projectionMatrix * \r\n        modelViewMatrix * \r\n         vec4(pos, 1.0);\r\n\r\n    vUv = uv;\r\n}\r\n`;\r\n\r\nexport { fragment, vertex };\r\n"},"lineCount":null}},"error":null,"hash":"2a9a55efca1397ed33f653d3e4c6ee31","cacheData":{"env":{}}}